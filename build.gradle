allprojects {
	apply plugin: 'java'
	apply plugin: 'eclipse'

	repositories {
		mavenCentral()
		maven {
			url 'https://oss.sonatype.org/content/repositories/snapshots/'
		}
	}

	group = 'com.jibbrjabbr'
	version = '0.5'
	
	sourceCompatibility = '1.8'
	targetCompatibility = '1.8'
	
	tasks.withType(JavaCompile) {
		options.encoding = 'UTF-8'
	}
	
	tasks.withType(Test) {
		testLogging {
			exceptionFormat 'full'
		}
	}
	
	configurations {
		core {
			transitive = false
		}
		
		testPack {
			transitive = false
		}
		
		serverCore {
			transitive = true
		}
	}
	
	jar {
		manifest {
			attributes(
				"Implementation-Version": version
			)
		}
	}

	dependencies {
		
		// shared with the test project.
		// which might get made into a whole other thing
		// it's looking interesting
		core 'com.google.inject:guice:3.0'
		core 'com.google.inject.extensions:guice-multibindings:3.0'
		core 'org.javassist:javassist:3.18.2-GA'
		core 'org.slf4j:slf4j-api:1.7.6'
		core('ch.qos.logback:logback-classic:1.0.7') {
			exclude group: 'org.slf4j'
		}
		
		testPack 'org.hamcrest:hamcrest-library:1.3'
		testPack('junit:junit:4.11') {
			exclude group: 'org.hamcrest'
		}
		testPack('org.mockito:mockito-core:1.9.5') {
			exclude group: 'org.hamcrest'
		}
		
		serverCore configurations.core
		serverCore 'io.netty:netty-all:4.0.23.Final'
		serverCore 'org.mozilla:rhino:1.7R4'
		serverCore 'com.fasterxml.jackson.core:jackson-databind:2.2.2'
		serverCore 'org.jsoup:jsoup:1.8.1'
	}
	
	eclipseClasspath.doFirst {
				
		Map<String, String> sourceMap = new HashMap<String, String>()
		project.sourceSets.each { sourceSet ->
			def classesOut = project.relativePath(sourceSet.output.classesDir)
			def resourcesOut = project.relativePath(sourceSet.output.resourcesDir)
			
			sourceSet.java.srcDirs.each { dir ->
				sourceMap[project.relativePath(dir)] = classesOut
			}
			
			sourceSet.resources.srcDirs.each { dir ->
				sourceMap[project.relativePath(dir)] = resourcesOut
			}
		}
	
		eclipse.classpath.file {
			whenMerged { classpath ->
				classpath.entries.findAll { entry -> 
					entry.kind == 'src' && sourceMap.containsKey(entry.path) 
				}.each { entry -> 
					entry.output = sourceMap[entry.path];
				}
			}
		}
	}
}

subprojects {
	
	/*
	apply plugin: 'jacoco'
	
	jacoco {
		toolVersion = '0.7.0.201403182114'
	}
	
	check.dependsOn jacocoTestReport
	*/
	
	jar {
		manifest {
			attributes(
				"Implementation-Title": project(':').name + '-' + project.name,
			)
		}
	}
	
	task sourcesJar(type: Jar, dependsOn: classes) {
		classifier = 'sources'
		from sourceSets.main.allSource
	}
	
	javadoc {
		options.memberLevel = org.gradle.external.javadoc.JavadocMemberLevel.PACKAGE
		options.stylesheetFile(rootProject.file('src/main/javadoc/stylesheet.css'))
		options.footer(
			'<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shCore.js" type="text/javascript"></script>' + 
			'<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJava.js" type="text/javascript"></script>' +
			'<script src="http://alexgorbatchev.com/pub/sh/current/scripts/shBrushJscript.js" type="text/javascript"></script>' +
			'<script type="text/javascript">SyntaxHighlighter.defaults["auto-links"] = false;SyntaxHighlighter.defaults["tab-size"] = 2;SyntaxHighlighter.all();</script>'
		)
	}
	
	task javadocJar(type: Jar, dependsOn: javadoc) {
		classifier = 'javadoc'
		from javadoc.destinationDir
	}
}

// configures the jar to be the actual final build product
jar {
	
	dependsOn ':kernel:jar'
	
	baseName = project.name
		
	from project(':bootstrapper').sourceSets.main.output
	
	metaInf {
		into 'system'
		from configurations.serverCore.files
		from project(":kernel").configurations.archives.allArtifacts.collect { it.file }
	}
	
	// write the sha1 of the libs into a file
	
	manifest {
		attributes (
			'Main-Class': 'jj.JJ',
			'Implementation-Title': project.name
		)
	}
	
	doLast {
		new File(destinationDir, 'system').deleteDir()
	}
}



/**
 * Wraps up the logic for starting/stopping a JibbrJabbr instance, given a server jar, app base, and place to
 * redirect logs.
 * 
 * For now, used as a smoke test - can we start the server at all?
 */
class JibbrJabbrServer {
	
	private final ProcessBuilder pb
	private Process p
	private Integer exit
	private final int port;
	
	public JibbrJabbrServer(File serverJar, File logDir, File appBase, int port) {
		this.port = port;
		pb = new ProcessBuilder('java', '-jar', serverJar.name, "app=${appBase}", "port=${port}")
		pb.directory(serverJar.parentFile).redirectOutput(new File(logDir, 'out.log')).redirectError(new File(logDir, 'error.log'))
	}
	
	public void start() {
		if (p != null) throw new IllegalStateException("this JibbrJabbr instance was already started")
		p = pb.start();
		
		// should be enough? find a better way! maybe keep trying a passed-in port every second until it accepts a connection, bail in 10 seconds?
		
		Thread.sleep(3000)
	}
	
	public void stop() {
		if (p == null) throw new IllegalStateException("this JibbrJabbr instance was not started")
		try {
			exit = p.exitValue() // may have stopped already due to error
		} catch (IllegalThreadStateException ise) {
			p.getOutputStream().write(3) // does this terminate it?  let's see!
			p.getOutputStream().flush()
			p.waitFor()
			exit = p.exitValue()
		}
		p = null;
	}
	
	public Integer exit() {
		return exit;
	}
}

def findApp(String path) {
	def base = project(':kernel').sourceSets.test.resources.srcDirs.find();
	
	return new File(base, path);
}

task startJibbrJabbr(dependsOn: ':jar') {
	
	finalizedBy 'stopJibbrJabbr'
	
	ext {
		server = new JibbrJabbrServer(jar.archivePath, buildDir, findApp('/app'), 8080);
	}
	
	doLast {
		server.start()
	}
}

task stopJibbrJabbr(dependsOn: startJibbrJabbr) << {
	startJibbrJabbr.server.stop()
	println startJibbrJabbr.server.exit
}
